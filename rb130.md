## Blocks
### Closures in Ruby
* "Chunks of code" saved and executed at a later time.
* 3 ways to work w/ closures:
  1. Instantiating an object from the `Proc` class
  2. Using blocks
  3. Using lambdas
* They're **binding** in that they retain references to their surrounding *artifacts* (i.e. variables, methods, objects, etc)


### Writing Methods w/ Blocks
* In Ruby, every method can take an optional block as an **implicit** argument.

#### Yielding
It lets us invoke our passed in block argument from within the method
* wrap in a conditional using `Kernel#block_given?` to allow method w/ `yield` to be invoked with or without a block (i.e. without raising a `LoadJumpError`)
* **Use case:** `Yield` allows future developers to inject additional code in our method without modifying the method implementation.

#### Passing Execution to the Block
Shown a code example of how execution goes from method invocation to method implementation, then jumps to the block.

#### Yielding w/ an argument
```ruby
3.times do |num|
  puts num
end
```
`3` is the calling object.
`times` is the method being invoked
`num` between the pipes, `| |`, is the *block paramenter*
`num` **within the block** is the *block local variable*

* remember not to name your *block parameter* the same name as a local variable defined outside the block as this will cause *variable shadowing* (i.e. we won't be able to access the variable in the outer scope).

To add to the previous use case, we can make our methods flexible by passing an argument to the block. This allows users to do what they will with that argument at method invocation time.

**arity** rule regarding the number of arguments you have to pass to a block, `proc`, or `lambda`.
  * blocks & `proc`s have **lenient arity** which means Ruby won't raise an error if we pass too few or too many arugments to either
  * methods & `lambda`s have **strict arity** meaning we have to pass the exact number of arguments that the method or `lambda` expects or Ruby will raise an `ArgumentError`.

**Arity** rules are ignored when dealing with complex method arguments (e.g. optional, variable, variable keyword, etc.). Optional parameters in a method or block? Arity rules don't apply to those arguments.


#### Return value of yielding to a block
```ruby
def compare(str)
  puts "Before: #{str}"
  after = yield(str)
  puts "After: #{after}"
end

compare('hello') { |word| word.upcase }
```
Blocks, like methods, have a return value and it's the last expression evaluated in the block too.

REMEMBER: `nil` in string interlpolation evaluates to an empty string.

#### When to use blocks in your own methods
Two main use cases:
1. Defer some implementation code to method invocation decision.
* **What?** *Method implementor* isn't 100% sure what the *method caller* wants to do so the ability to *refine* the method implementation without modifying it for others is provided.
* **Why?** Life without blocks, is a long list of `flags` for the use (method caller) to use to specify what they want. Or it's a lot more methods, each with a slightly different implementation (`#transform_all`, `#transform_every_other`, etc.).
```ruby
def compare(str, flag)
  after = case flag
          when :upcase
            str.upcase
          when :capitalize
            str.capitalize
          # etc, we could have a lot of 'when' clauses
          end

  puts "Before: #{str}"
  puts "After: #{after}"
end

compare("hello", :upcase)
```
* **When?** If you're calling a method from multiple places, with one little tweak in each case, it may be a good idea to try implementing the method in a generic way by yielding to a block.

2. Methods that need to perform some "before" and "after" actions - **sandwich code**.
* **What?** Generic code that performs a 'before' & 'after' action that's left to the *method caller* to determine.
* **Why?** Timing, logging, notification systems are all examples where before/after actions are important. Another area is in resource manangemment, or interfacing with the operating system. Many OS interfaces require developers to first allocate a portion of a resource, then perform some 'clean-up' to free up that resource. Forgetting to do the clean-up can result in dramatic bugs -- system crashes, memory leaks, file system corruption. Sandwich code allows us to automate this clean-up.


#### Methods with an explicit block parameter
An **explicit block** is a block that gets assigned to a method parameter so that it can be managed like any other object -- it can be reassigned, passed to other methods, and invoked many times.

To define an explicit block, add a parameter to the method definition that begins with an `&` (ampersand) character.
```ruby
def test(&block)
  puts "What's &block? #{block}"
end

test { sleep(1) }

# What's &block? #<Proc:0x007f98e32b83c8@(irb):59>
# => nil
```
* The `&` is a special parameter that converts the block into a simple `Proc` object.
* `&` is dropped when referring to the parameter inside the method.

**Why an explicit block parameter?** 
Provides more flexibility, without a variable to assign the block to we can't do anything beyond `yielding` to it and testing to see if it's there.

With a variable that represents the block, we can *pass the block to another method* 
```ruby
def display(block)
  block.call(">>>") # Passing the prefix argument to the block
end

def test(&block)
  puts "1"
  display(block)
  puts "2"
end

test { |prefix| puts prefix + "xyz" }
```
* We use `#call` to invoke a `Proc` object
* We can pass arguments to an explicit block by using them as arguments to `#call`

**Important note:** Things get a bit more complicated if the caller passes in a `Proc` object, a `lambda`, or some other object to a method that takes an explicit block. But we won't go into that.

#### Using Closures
In addition to the information about **closures** further up in this doc, they can use and even update variables in that scope when they're executed. Even if the block, `Proc`, or `lambda` is called from somewhere else.
```ruby
def for_each_in(arr)
  arr.each { |element| yield element }
end

arr = [1, 2, 3, 4, 5]
results = [0]

for_each_in(arr) do |number|
  total = results[-1] + number
  results.push(total)
end

p results # => [0, 1, 3, 6, 10, 15]
```
* Although the block called with `#for_each_in` is called from inside the method (thanks to `yield`), it still has access to the `results` array thru closure.

Closures are especially powerful when a method or block returns them. Of the 3 ways to implement closures, we can only return `Proc`s and `lambda`s. Difference is primarily in syntax.
```ruby
def sequence
  counter = 0
  Proc.new { counter += 1 }
end

s1 = sequence
p s1.call           # => 1
p s1.call           # => 2
p s1.call           # => 3
puts

s2 = sequence
p s2.call           # => 1
p s1.call           # => 4 (note: this is s1)
p s2.call           # => 2
```
* `#sequence` method returns a `Proc` that forms a closure with the local variable `counter`
* Each time we called `Proc`, it incremented its own private copy of the `counter` variable.
* We can create multiple `Proc`s from `#sequence`, and each will have its own independent copy of `counter`. We see this when we call `#sequence` for a second time, assigning the return value (the `Proc` object) to `s2`. When we call our `Proc` object on `s2` the counter starts at 1. This demonstrates that the bound artifacts are separate and indepent of each other.

#### Summary
* blocks are a good use case for "sandwich code" scenarios, like closing a `File` automatically.
* methods and blocks can return a chunk of code by returning a `Proc` or `lambda`.


### Assignment: TodoList
Working w/ `Todo` objects and creating a *collection* class `TodoList`
**Why?** Using our own collection class allows us to add our own collection level attributes as well as behaviors specifc to a *todo lists*. For example:
* we can add a title or due date for our collection of `Todo`s
* we can make sure our collection class only deals with `Todo` objects

Backing mechanism being used internally in our `TodoList` class is an `Array`. 

**LS solution vs. My solution**
* I could have utilized my own methods more (e.g. using `#item_at` which relies on `#fetch` rather than `#fetch`!)
* LS coded this `@todos.delete(item_at(idx))` compared to what I wrote, `todos.delete_at(idx) if self.item_at(idx)`
* LS's `#to_s` method made use of `\n` the new line character after making one long string of a title & items.


### Assignment: TodoList#each
I was missing how to piggy-back off of `Array#each`
```ruby
  def each
    @todos.each do |todo|
      yield(todo)
    end
  end
```
The answer was to do it from **within** it!

### Assignment: TodoList methods
Don't need `self` because `#each` and `#select` know what collection they're iterating through! I defined them with `self`!
```ruby
  def mark_done(title)
    find_by_title(title) && find_by_title(title).done!
  end
```
If title isn't found, `nil` is returned which `#done!` can't handle (NoMethodError is railed because we're trying to call it for `nil:NilClass`). So using `&&` helps because it'll short circuit if no title is found and not even attempt to mark a non-existent todo object done.

