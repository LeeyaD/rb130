## Blocks
### Closures in Ruby
* "Chunks of code" saved and executed at a later time.
* 3 ways to work w/ closures:
  1. Instantiating an object from the `Proc` class
  2. Using blocks
  3. Using lambdas
* They're **binding** in that they retain references to their surrounding *artifacts* (i.e. variables, methods, objects, etc)


### Writing Methods w/ Blocks
* In Ruby, every method can take an optional block as an **implicit** argument.

#### Yielding
It lets us invoke our passed in block argument from within the method
* wrap in a conditional using `Kernel#block_given?` to allow method w/ `yield` to be invoked with or without a block (i.e. without raising a `LoadJumpError`)
* **Use case:** `Yield` allows future developers to inject additional code in our method without modifying the method implementation.

#### Passing Execution to the Block
Shown a code example of how execution goes from method invocation to method implementation, then jumps to the block.

#### Yielding w/ an argument
```ruby
3.times do |num|
  puts num
end
```
`3` is the calling object.
`times` is the method being invoked
`num` between the pipes, `| |`, is the *block paramenter*
`num` **within the block** is the *block local variable*

* remember not to name your *block parameter* the same name as a local variable defined outside the block as this will cause *variable shadowing* (i.e. we won't be able to access the variable in the outer scope).

To add to the previous use case, we can make our methods flexible by passing an argument to the block. This allows users to do what they will with that argument at method invocation time.

**arity** rule regarding the number of arguments you have to pass to a block, `proc`, or `lambda`.
  * blocks & `proc`s have **lenient arity** which means Ruby won't raise an error if we pass too few or too many arugments to either
  * methods & `lambda`s have **strict arity** meaning we have to pass the exact number of arguments that the method or `lambda` expects or Ruby will raise an `ArgumentError`.

**Arity** rules are ignored when dealing with complex method arguments (e.g. optional, variable, variable keyword, etc.). Optional parameters in a method or block? Arity rules don't apply to those arguments.


#### Return value of yielding to a block

